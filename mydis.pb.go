// Code generated by protoc-gen-go.
// source: mydis.proto
// DO NOT EDIT!

/*
Package mydis is a generated protocol buffer package.

It is generated from these files:
	mydis.proto

It has these top-level messages:
	Null
	Key
	Bool
	Expiration
	ByteValue
	IntValue
	FloatValue
	KeysList
	List
	ListItem
	ErrorHash
	StringHash
	Hash
	HashField
	HashFieldSet
	WatchRequest
	Event
*/
package mydis

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Event_EventType int32

const (
	Event_PUT    Event_EventType = 0
	Event_DELETE Event_EventType = 1
)

var Event_EventType_name = map[int32]string{
	0: "PUT",
	1: "DELETE",
}
var Event_EventType_value = map[string]int32{
	"PUT":    0,
	"DELETE": 1,
}

func (x Event_EventType) String() string {
	return proto.EnumName(Event_EventType_name, int32(x))
}
func (Event_EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 0} }

// Null object.
type Null struct {
}

func (m *Null) Reset()                    { *m = Null{} }
func (m *Null) String() string            { return proto.CompactTextString(m) }
func (*Null) ProtoMessage()               {}
func (*Null) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Key object.
type Key struct {
	Key               string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Limit             int64  `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
	Revision          int64  `protobuf:"varint,4,opt,name=revision" json:"revision,omitempty"`
	MinModRevision    int64  `protobuf:"varint,10,opt,name=minModRevision" json:"minModRevision,omitempty"`
	MaxModRevision    int64  `protobuf:"varint,11,opt,name=maxModRevision" json:"maxModRevision,omitempty"`
	MinCreateRevision int64  `protobuf:"varint,12,opt,name=minCreateRevision" json:"minCreateRevision,omitempty"`
	MaxCreateRevision int64  `protobuf:"varint,13,opt,name=maxCreateRevision" json:"maxCreateRevision,omitempty"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Key) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Key) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Key) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *Key) GetMinModRevision() int64 {
	if m != nil {
		return m.MinModRevision
	}
	return 0
}

func (m *Key) GetMaxModRevision() int64 {
	if m != nil {
		return m.MaxModRevision
	}
	return 0
}

func (m *Key) GetMinCreateRevision() int64 {
	if m != nil {
		return m.MinCreateRevision
	}
	return 0
}

func (m *Key) GetMaxCreateRevision() int64 {
	if m != nil {
		return m.MaxCreateRevision
	}
	return 0
}

// Bool object.
type Bool struct {
	Value bool `protobuf:"varint,1,opt,name=value" json:"value,omitempty"`
}

func (m *Bool) Reset()                    { *m = Bool{} }
func (m *Bool) String() string            { return proto.CompactTextString(m) }
func (*Bool) ProtoMessage()               {}
func (*Bool) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Bool) GetValue() bool {
	if m != nil {
		return m.Value
	}
	return false
}

// Expiration object.
type Expiration struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Exp int64  `protobuf:"zigzag64,2,opt,name=exp" json:"exp,omitempty"`
}

func (m *Expiration) Reset()                    { *m = Expiration{} }
func (m *Expiration) String() string            { return proto.CompactTextString(m) }
func (*Expiration) ProtoMessage()               {}
func (*Expiration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Expiration) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Expiration) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

// ByteValue object.
type ByteValue struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ByteValue) Reset()                    { *m = ByteValue{} }
func (m *ByteValue) String() string            { return proto.CompactTextString(m) }
func (*ByteValue) ProtoMessage()               {}
func (*ByteValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ByteValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ByteValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// IntValue object.
type IntValue struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value int64  `protobuf:"zigzag64,2,opt,name=value" json:"value,omitempty"`
}

func (m *IntValue) Reset()                    { *m = IntValue{} }
func (m *IntValue) String() string            { return proto.CompactTextString(m) }
func (*IntValue) ProtoMessage()               {}
func (*IntValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *IntValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *IntValue) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// FloatValue object.
type FloatValue struct {
	Key   string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *FloatValue) Reset()                    { *m = FloatValue{} }
func (m *FloatValue) String() string            { return proto.CompactTextString(m) }
func (*FloatValue) ProtoMessage()               {}
func (*FloatValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FloatValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *FloatValue) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// KeysList object.
type KeysList struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *KeysList) Reset()                    { *m = KeysList{} }
func (m *KeysList) String() string            { return proto.CompactTextString(m) }
func (*KeysList) ProtoMessage()               {}
func (*KeysList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *KeysList) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// List object.
type List struct {
	Key   string   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value [][]byte `protobuf:"bytes,2,rep,name=value,proto3" json:"value,omitempty"`
	Limit int64    `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
}

func (m *List) Reset()                    { *m = List{} }
func (m *List) String() string            { return proto.CompactTextString(m) }
func (*List) ProtoMessage()               {}
func (*List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *List) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *List) GetValue() [][]byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *List) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// ListItem object.
type ListItem struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Index int64  `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ListItem) Reset()                    { *m = ListItem{} }
func (m *ListItem) String() string            { return proto.CompactTextString(m) }
func (*ListItem) ProtoMessage()               {}
func (*ListItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ListItem) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ListItem) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ListItem) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// ErrorHash object.
type ErrorHash struct {
	Errors map[string]string `protobuf:"bytes,1,rep,name=errors" json:"errors,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ErrorHash) Reset()                    { *m = ErrorHash{} }
func (m *ErrorHash) String() string            { return proto.CompactTextString(m) }
func (*ErrorHash) ProtoMessage()               {}
func (*ErrorHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ErrorHash) GetErrors() map[string]string {
	if m != nil {
		return m.Errors
	}
	return nil
}

// StringHash object.
type StringHash struct {
	Key   string            `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value map[string]string `protobuf:"bytes,2,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StringHash) Reset()                    { *m = StringHash{} }
func (m *StringHash) String() string            { return proto.CompactTextString(m) }
func (*StringHash) ProtoMessage()               {}
func (*StringHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *StringHash) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringHash) GetValue() map[string]string {
	if m != nil {
		return m.Value
	}
	return nil
}

// Hash object.
type Hash struct {
	Key   string            `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value map[string][]byte `protobuf:"bytes,2,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Hash) Reset()                    { *m = Hash{} }
func (m *Hash) String() string            { return proto.CompactTextString(m) }
func (*Hash) ProtoMessage()               {}
func (*Hash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Hash) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Hash) GetValue() map[string][]byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// HashField object.
type HashField struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Field string `protobuf:"bytes,2,opt,name=field" json:"field,omitempty"`
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *HashField) Reset()                    { *m = HashField{} }
func (m *HashField) String() string            { return proto.CompactTextString(m) }
func (*HashField) ProtoMessage()               {}
func (*HashField) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *HashField) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *HashField) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *HashField) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// HashFieldSet object.
type HashFieldSet struct {
	Key   string   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Field []string `protobuf:"bytes,2,rep,name=field" json:"field,omitempty"`
	Value [][]byte `protobuf:"bytes,3,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *HashFieldSet) Reset()                    { *m = HashFieldSet{} }
func (m *HashFieldSet) String() string            { return proto.CompactTextString(m) }
func (*HashFieldSet) ProtoMessage()               {}
func (*HashFieldSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *HashFieldSet) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *HashFieldSet) GetField() []string {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *HashFieldSet) GetValue() [][]byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// WatchRequest object.
type WatchRequest struct {
	Key    string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Prefix bool   `protobuf:"varint,2,opt,name=prefix" json:"prefix,omitempty"`
	Rev    int64  `protobuf:"varint,3,opt,name=rev" json:"rev,omitempty"`
	Id     int64  `protobuf:"varint,4,opt,name=id" json:"id,omitempty"`
	Cancel bool   `protobuf:"varint,5,opt,name=cancel" json:"cancel,omitempty"`
}

func (m *WatchRequest) Reset()                    { *m = WatchRequest{} }
func (m *WatchRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchRequest) ProtoMessage()               {}
func (*WatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *WatchRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *WatchRequest) GetPrefix() bool {
	if m != nil {
		return m.Prefix
	}
	return false
}

func (m *WatchRequest) GetRev() int64 {
	if m != nil {
		return m.Rev
	}
	return 0
}

func (m *WatchRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WatchRequest) GetCancel() bool {
	if m != nil {
		return m.Cancel
	}
	return false
}

// Event object.
type Event struct {
	Type     Event_EventType `protobuf:"varint,1,opt,name=type,enum=mydis.Event_EventType" json:"type,omitempty"`
	Current  *ByteValue      `protobuf:"bytes,3,opt,name=current" json:"current,omitempty"`
	Previous *ByteValue      `protobuf:"bytes,4,opt,name=previous" json:"previous,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Event) GetType() Event_EventType {
	if m != nil {
		return m.Type
	}
	return Event_PUT
}

func (m *Event) GetCurrent() *ByteValue {
	if m != nil {
		return m.Current
	}
	return nil
}

func (m *Event) GetPrevious() *ByteValue {
	if m != nil {
		return m.Previous
	}
	return nil
}

func init() {
	proto.RegisterType((*Null)(nil), "mydis.Null")
	proto.RegisterType((*Key)(nil), "mydis.Key")
	proto.RegisterType((*Bool)(nil), "mydis.Bool")
	proto.RegisterType((*Expiration)(nil), "mydis.Expiration")
	proto.RegisterType((*ByteValue)(nil), "mydis.ByteValue")
	proto.RegisterType((*IntValue)(nil), "mydis.IntValue")
	proto.RegisterType((*FloatValue)(nil), "mydis.FloatValue")
	proto.RegisterType((*KeysList)(nil), "mydis.KeysList")
	proto.RegisterType((*List)(nil), "mydis.List")
	proto.RegisterType((*ListItem)(nil), "mydis.ListItem")
	proto.RegisterType((*ErrorHash)(nil), "mydis.ErrorHash")
	proto.RegisterType((*StringHash)(nil), "mydis.StringHash")
	proto.RegisterType((*Hash)(nil), "mydis.Hash")
	proto.RegisterType((*HashField)(nil), "mydis.HashField")
	proto.RegisterType((*HashFieldSet)(nil), "mydis.HashFieldSet")
	proto.RegisterType((*WatchRequest)(nil), "mydis.WatchRequest")
	proto.RegisterType((*Event)(nil), "mydis.Event")
	proto.RegisterEnum("mydis.Event_EventType", Event_EventType_name, Event_EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Mydis service

type MydisClient interface {
	// -- core functions
	// Keys returns a list of valid keys.
	Keys(ctx context.Context, in *Null, opts ...grpc.CallOption) (*KeysList, error)
	// KeysWithPrefix returns a list of keys with the given prefix.
	KeysWithPrefix(ctx context.Context, in *Key, opts ...grpc.CallOption) (*KeysList, error)
	// Has checks if the cache has the given key and that it is not expired.
	Has(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Bool, error)
	// SetExpire sets the expiration on a key.
	SetExpire(ctx context.Context, in *Expiration, opts ...grpc.CallOption) (*Null, error)
	// Lock a key from being modified.
	Lock(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Null, error)
	// LockWithTimeout locks a key, waiting for the given number of seconds if already locked before returning an error.
	LockWithTimeout(ctx context.Context, in *Expiration, opts ...grpc.CallOption) (*Null, error)
	// Unlock a key for modifications.
	Unlock(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Null, error)
	// UnlockThenSet unlocks a key, then immediately sets its byte array value.
	UnlockThenSet(ctx context.Context, in *ByteValue, opts ...grpc.CallOption) (*Null, error)
	// UnlockThenSetList unlocks a key, then immediately sets its list value.
	UnlockThenSetList(ctx context.Context, in *List, opts ...grpc.CallOption) (*Null, error)
	// Delete removes a key from the cache.
	Delete(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Null, error)
	// Clear the cache.
	Clear(ctx context.Context, in *Null, opts ...grpc.CallOption) (*Null, error)
	// -- bytes functions
	// Get gets the value for the given key as a byte slice.
	Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*ByteValue, error)
	// GetMany gets a list of values from the cache.
	GetMany(ctx context.Context, in *KeysList, opts ...grpc.CallOption) (*Hash, error)
	// GetWithPrefix returns the keys with the given prefix.
	GetWithPrefix(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Hash, error)
	// Set sets the byte value.
	Set(ctx context.Context, in *ByteValue, opts ...grpc.CallOption) (*Null, error)
	// SetNX sets a value only if the key doesn't exist, returns true if changed.
	SetNX(ctx context.Context, in *ByteValue, opts ...grpc.CallOption) (*Bool, error)
	// SetMany values, returning a map[key]errorText for any errors.
	SetMany(ctx context.Context, in *Hash, opts ...grpc.CallOption) (*ErrorHash, error)
	// Length returns the length of the value for the given key.
	Length(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error)
	// -- number functions
	// GetInt gets an integer value for the given key.
	GetInt(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error)
	// GetFloat gets a float value for the given key.
	GetFloat(ctx context.Context, in *Key, opts ...grpc.CallOption) (*FloatValue, error)
	// SetInt sets an integer.
	SetInt(ctx context.Context, in *IntValue, opts ...grpc.CallOption) (*Null, error)
	// SetFloat sets a float.
	SetFloat(ctx context.Context, in *FloatValue, opts ...grpc.CallOption) (*Null, error)
	// IncrementInt increment an integer stored at the given key by the given number and returns new value.
	IncrementInt(ctx context.Context, in *IntValue, opts ...grpc.CallOption) (*IntValue, error)
	// DecrementInt decrements an integer stored at the given key by the given number and returns new value.
	DecrementInt(ctx context.Context, in *IntValue, opts ...grpc.CallOption) (*IntValue, error)
	// IncrementFloat increment a float stored at the given key by the given number and returns new value.
	IncrementFloat(ctx context.Context, in *FloatValue, opts ...grpc.CallOption) (*FloatValue, error)
	// DecrementFloat decrements a float stored at the given key by the given number and returns new value.
	DecrementFloat(ctx context.Context, in *FloatValue, opts ...grpc.CallOption) (*FloatValue, error)
	// -- list functions
	// GetList gets a list from the cache.
	GetList(ctx context.Context, in *Key, opts ...grpc.CallOption) (*List, error)
	// GetListItem gets a single item from a list by index, supports negative indexing.
	GetListItem(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*ByteValue, error)
	// SetList sets a list in the cache.
	SetList(ctx context.Context, in *List, opts ...grpc.CallOption) (*Null, error)
	// SetListItem sets a single item in a list by index.
	SetListItem(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error)
	// ListLength returns the number of items in a list.
	ListLength(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error)
	// ListLimit sets the maximum length of a list, removing items from the top once limit is reached.
	ListLimit(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error)
	// ListInsert inserts a new item at the given index in the list.
	ListInsert(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error)
	// ListAppend inserts a new item at the end of the list.
	ListAppend(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error)
	// ListPopLeft returns and removes the first item in a list.
	ListPopLeft(ctx context.Context, in *Key, opts ...grpc.CallOption) (*ByteValue, error)
	// ListPopRight returns and removes the last item in a list.
	ListPopRight(ctx context.Context, in *Key, opts ...grpc.CallOption) (*ByteValue, error)
	// ListHas determines if a list contains an item, returns index or -1 if not found.
	ListHas(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*IntValue, error)
	// ListDelete removes an item from a list by index.
	ListDelete(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error)
	// ListDeleteItem removes the first occurance of value from a list, returns index of removed item or -1 for not found.
	ListDeleteItem(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*IntValue, error)
	// -- hash functions
	// GetHash gets a hash from the cache.
	GetHash(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Hash, error)
	// GetHashField gets a single value in a hash.
	GetHashField(ctx context.Context, in *HashField, opts ...grpc.CallOption) (*ByteValue, error)
	// GetHashFields gets multiple hash values.
	GetHashFields(ctx context.Context, in *HashFieldSet, opts ...grpc.CallOption) (*Hash, error)
	// HashHas determines if a hash has a given field.
	HashHas(ctx context.Context, in *HashField, opts ...grpc.CallOption) (*Bool, error)
	// HashLength returns the number of fields in a hash.
	HashLength(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error)
	// HashFields gets a list of the fields in a hash.
	HashFields(ctx context.Context, in *Key, opts ...grpc.CallOption) (*KeysList, error)
	// HashValues gets a list of the values in a hash.
	HashValues(ctx context.Context, in *Key, opts ...grpc.CallOption) (*List, error)
	// SetHash sets the value of a hash.
	SetHash(ctx context.Context, in *Hash, opts ...grpc.CallOption) (*Null, error)
	// SetHashField sets a single value in a hash.
	SetHashField(ctx context.Context, in *HashField, opts ...grpc.CallOption) (*Null, error)
	// SetHashFields sets multiple values in a hash.
	SetHashFields(ctx context.Context, in *Hash, opts ...grpc.CallOption) (*Null, error)
	// DelHashField deletes a field from a hash.
	DelHashField(ctx context.Context, in *HashField, opts ...grpc.CallOption) (*Null, error)
	// -- push functions
	// Watch for changes to a key.
	Watch(ctx context.Context, opts ...grpc.CallOption) (Mydis_WatchClient, error)
}

type mydisClient struct {
	cc *grpc.ClientConn
}

func NewMydisClient(cc *grpc.ClientConn) MydisClient {
	return &mydisClient{cc}
}

func (c *mydisClient) Keys(ctx context.Context, in *Null, opts ...grpc.CallOption) (*KeysList, error) {
	out := new(KeysList)
	err := grpc.Invoke(ctx, "/mydis.Mydis/Keys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) KeysWithPrefix(ctx context.Context, in *Key, opts ...grpc.CallOption) (*KeysList, error) {
	out := new(KeysList)
	err := grpc.Invoke(ctx, "/mydis.Mydis/KeysWithPrefix", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) Has(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Bool, error) {
	out := new(Bool)
	err := grpc.Invoke(ctx, "/mydis.Mydis/Has", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetExpire(ctx context.Context, in *Expiration, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetExpire", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) Lock(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/Lock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) LockWithTimeout(ctx context.Context, in *Expiration, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/LockWithTimeout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) Unlock(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/Unlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) UnlockThenSet(ctx context.Context, in *ByteValue, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/UnlockThenSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) UnlockThenSetList(ctx context.Context, in *List, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/UnlockThenSetList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) Delete(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) Clear(ctx context.Context, in *Null, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/Clear", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*ByteValue, error) {
	out := new(ByteValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) GetMany(ctx context.Context, in *KeysList, opts ...grpc.CallOption) (*Hash, error) {
	out := new(Hash)
	err := grpc.Invoke(ctx, "/mydis.Mydis/GetMany", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) GetWithPrefix(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Hash, error) {
	out := new(Hash)
	err := grpc.Invoke(ctx, "/mydis.Mydis/GetWithPrefix", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) Set(ctx context.Context, in *ByteValue, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetNX(ctx context.Context, in *ByteValue, opts ...grpc.CallOption) (*Bool, error) {
	out := new(Bool)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetNX", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetMany(ctx context.Context, in *Hash, opts ...grpc.CallOption) (*ErrorHash, error) {
	out := new(ErrorHash)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetMany", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) Length(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/Length", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) GetInt(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/GetInt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) GetFloat(ctx context.Context, in *Key, opts ...grpc.CallOption) (*FloatValue, error) {
	out := new(FloatValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/GetFloat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetInt(ctx context.Context, in *IntValue, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetInt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetFloat(ctx context.Context, in *FloatValue, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetFloat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) IncrementInt(ctx context.Context, in *IntValue, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/IncrementInt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) DecrementInt(ctx context.Context, in *IntValue, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/DecrementInt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) IncrementFloat(ctx context.Context, in *FloatValue, opts ...grpc.CallOption) (*FloatValue, error) {
	out := new(FloatValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/IncrementFloat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) DecrementFloat(ctx context.Context, in *FloatValue, opts ...grpc.CallOption) (*FloatValue, error) {
	out := new(FloatValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/DecrementFloat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) GetList(ctx context.Context, in *Key, opts ...grpc.CallOption) (*List, error) {
	out := new(List)
	err := grpc.Invoke(ctx, "/mydis.Mydis/GetList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) GetListItem(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*ByteValue, error) {
	out := new(ByteValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/GetListItem", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetList(ctx context.Context, in *List, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetListItem(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetListItem", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) ListLength(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/ListLength", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) ListLimit(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/ListLimit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) ListInsert(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/ListInsert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) ListAppend(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/ListAppend", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) ListPopLeft(ctx context.Context, in *Key, opts ...grpc.CallOption) (*ByteValue, error) {
	out := new(ByteValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/ListPopLeft", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) ListPopRight(ctx context.Context, in *Key, opts ...grpc.CallOption) (*ByteValue, error) {
	out := new(ByteValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/ListPopRight", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) ListHas(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/ListHas", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) ListDelete(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/ListDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) ListDeleteItem(ctx context.Context, in *ListItem, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/ListDeleteItem", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) GetHash(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Hash, error) {
	out := new(Hash)
	err := grpc.Invoke(ctx, "/mydis.Mydis/GetHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) GetHashField(ctx context.Context, in *HashField, opts ...grpc.CallOption) (*ByteValue, error) {
	out := new(ByteValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/GetHashField", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) GetHashFields(ctx context.Context, in *HashFieldSet, opts ...grpc.CallOption) (*Hash, error) {
	out := new(Hash)
	err := grpc.Invoke(ctx, "/mydis.Mydis/GetHashFields", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) HashHas(ctx context.Context, in *HashField, opts ...grpc.CallOption) (*Bool, error) {
	out := new(Bool)
	err := grpc.Invoke(ctx, "/mydis.Mydis/HashHas", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) HashLength(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := grpc.Invoke(ctx, "/mydis.Mydis/HashLength", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) HashFields(ctx context.Context, in *Key, opts ...grpc.CallOption) (*KeysList, error) {
	out := new(KeysList)
	err := grpc.Invoke(ctx, "/mydis.Mydis/HashFields", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) HashValues(ctx context.Context, in *Key, opts ...grpc.CallOption) (*List, error) {
	out := new(List)
	err := grpc.Invoke(ctx, "/mydis.Mydis/HashValues", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetHash(ctx context.Context, in *Hash, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetHashField(ctx context.Context, in *HashField, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetHashField", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) SetHashFields(ctx context.Context, in *Hash, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/SetHashFields", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) DelHashField(ctx context.Context, in *HashField, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := grpc.Invoke(ctx, "/mydis.Mydis/DelHashField", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mydisClient) Watch(ctx context.Context, opts ...grpc.CallOption) (Mydis_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Mydis_serviceDesc.Streams[0], c.cc, "/mydis.Mydis/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &mydisWatchClient{stream}
	return x, nil
}

type Mydis_WatchClient interface {
	Send(*WatchRequest) error
	Recv() (*Event, error)
	grpc.ClientStream
}

type mydisWatchClient struct {
	grpc.ClientStream
}

func (x *mydisWatchClient) Send(m *WatchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mydisWatchClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Mydis service

type MydisServer interface {
	// -- core functions
	// Keys returns a list of valid keys.
	Keys(context.Context, *Null) (*KeysList, error)
	// KeysWithPrefix returns a list of keys with the given prefix.
	KeysWithPrefix(context.Context, *Key) (*KeysList, error)
	// Has checks if the cache has the given key and that it is not expired.
	Has(context.Context, *Key) (*Bool, error)
	// SetExpire sets the expiration on a key.
	SetExpire(context.Context, *Expiration) (*Null, error)
	// Lock a key from being modified.
	Lock(context.Context, *Key) (*Null, error)
	// LockWithTimeout locks a key, waiting for the given number of seconds if already locked before returning an error.
	LockWithTimeout(context.Context, *Expiration) (*Null, error)
	// Unlock a key for modifications.
	Unlock(context.Context, *Key) (*Null, error)
	// UnlockThenSet unlocks a key, then immediately sets its byte array value.
	UnlockThenSet(context.Context, *ByteValue) (*Null, error)
	// UnlockThenSetList unlocks a key, then immediately sets its list value.
	UnlockThenSetList(context.Context, *List) (*Null, error)
	// Delete removes a key from the cache.
	Delete(context.Context, *Key) (*Null, error)
	// Clear the cache.
	Clear(context.Context, *Null) (*Null, error)
	// -- bytes functions
	// Get gets the value for the given key as a byte slice.
	Get(context.Context, *Key) (*ByteValue, error)
	// GetMany gets a list of values from the cache.
	GetMany(context.Context, *KeysList) (*Hash, error)
	// GetWithPrefix returns the keys with the given prefix.
	GetWithPrefix(context.Context, *Key) (*Hash, error)
	// Set sets the byte value.
	Set(context.Context, *ByteValue) (*Null, error)
	// SetNX sets a value only if the key doesn't exist, returns true if changed.
	SetNX(context.Context, *ByteValue) (*Bool, error)
	// SetMany values, returning a map[key]errorText for any errors.
	SetMany(context.Context, *Hash) (*ErrorHash, error)
	// Length returns the length of the value for the given key.
	Length(context.Context, *Key) (*IntValue, error)
	// -- number functions
	// GetInt gets an integer value for the given key.
	GetInt(context.Context, *Key) (*IntValue, error)
	// GetFloat gets a float value for the given key.
	GetFloat(context.Context, *Key) (*FloatValue, error)
	// SetInt sets an integer.
	SetInt(context.Context, *IntValue) (*Null, error)
	// SetFloat sets a float.
	SetFloat(context.Context, *FloatValue) (*Null, error)
	// IncrementInt increment an integer stored at the given key by the given number and returns new value.
	IncrementInt(context.Context, *IntValue) (*IntValue, error)
	// DecrementInt decrements an integer stored at the given key by the given number and returns new value.
	DecrementInt(context.Context, *IntValue) (*IntValue, error)
	// IncrementFloat increment a float stored at the given key by the given number and returns new value.
	IncrementFloat(context.Context, *FloatValue) (*FloatValue, error)
	// DecrementFloat decrements a float stored at the given key by the given number and returns new value.
	DecrementFloat(context.Context, *FloatValue) (*FloatValue, error)
	// -- list functions
	// GetList gets a list from the cache.
	GetList(context.Context, *Key) (*List, error)
	// GetListItem gets a single item from a list by index, supports negative indexing.
	GetListItem(context.Context, *ListItem) (*ByteValue, error)
	// SetList sets a list in the cache.
	SetList(context.Context, *List) (*Null, error)
	// SetListItem sets a single item in a list by index.
	SetListItem(context.Context, *ListItem) (*Null, error)
	// ListLength returns the number of items in a list.
	ListLength(context.Context, *Key) (*IntValue, error)
	// ListLimit sets the maximum length of a list, removing items from the top once limit is reached.
	ListLimit(context.Context, *ListItem) (*Null, error)
	// ListInsert inserts a new item at the given index in the list.
	ListInsert(context.Context, *ListItem) (*Null, error)
	// ListAppend inserts a new item at the end of the list.
	ListAppend(context.Context, *ListItem) (*Null, error)
	// ListPopLeft returns and removes the first item in a list.
	ListPopLeft(context.Context, *Key) (*ByteValue, error)
	// ListPopRight returns and removes the last item in a list.
	ListPopRight(context.Context, *Key) (*ByteValue, error)
	// ListHas determines if a list contains an item, returns index or -1 if not found.
	ListHas(context.Context, *ListItem) (*IntValue, error)
	// ListDelete removes an item from a list by index.
	ListDelete(context.Context, *ListItem) (*Null, error)
	// ListDeleteItem removes the first occurance of value from a list, returns index of removed item or -1 for not found.
	ListDeleteItem(context.Context, *ListItem) (*IntValue, error)
	// -- hash functions
	// GetHash gets a hash from the cache.
	GetHash(context.Context, *Key) (*Hash, error)
	// GetHashField gets a single value in a hash.
	GetHashField(context.Context, *HashField) (*ByteValue, error)
	// GetHashFields gets multiple hash values.
	GetHashFields(context.Context, *HashFieldSet) (*Hash, error)
	// HashHas determines if a hash has a given field.
	HashHas(context.Context, *HashField) (*Bool, error)
	// HashLength returns the number of fields in a hash.
	HashLength(context.Context, *Key) (*IntValue, error)
	// HashFields gets a list of the fields in a hash.
	HashFields(context.Context, *Key) (*KeysList, error)
	// HashValues gets a list of the values in a hash.
	HashValues(context.Context, *Key) (*List, error)
	// SetHash sets the value of a hash.
	SetHash(context.Context, *Hash) (*Null, error)
	// SetHashField sets a single value in a hash.
	SetHashField(context.Context, *HashField) (*Null, error)
	// SetHashFields sets multiple values in a hash.
	SetHashFields(context.Context, *Hash) (*Null, error)
	// DelHashField deletes a field from a hash.
	DelHashField(context.Context, *HashField) (*Null, error)
	// -- push functions
	// Watch for changes to a key.
	Watch(Mydis_WatchServer) error
}

func RegisterMydisServer(s *grpc.Server, srv MydisServer) {
	s.RegisterService(&_Mydis_serviceDesc, srv)
}

func _Mydis_Keys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Null)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).Keys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/Keys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).Keys(ctx, req.(*Null))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_KeysWithPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).KeysWithPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/KeysWithPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).KeysWithPrefix(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_Has_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).Has(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/Has",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).Has(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetExpire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Expiration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetExpire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetExpire",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetExpire(ctx, req.(*Expiration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/Lock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).Lock(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_LockWithTimeout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Expiration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).LockWithTimeout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/LockWithTimeout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).LockWithTimeout(ctx, req.(*Expiration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/Unlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).Unlock(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_UnlockThenSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByteValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).UnlockThenSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/UnlockThenSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).UnlockThenSet(ctx, req.(*ByteValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_UnlockThenSetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(List)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).UnlockThenSetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/UnlockThenSetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).UnlockThenSetList(ctx, req.(*List))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).Delete(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Null)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).Clear(ctx, req.(*Null))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).Get(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_GetMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).GetMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/GetMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).GetMany(ctx, req.(*KeysList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_GetWithPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).GetWithPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/GetWithPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).GetWithPrefix(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByteValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).Set(ctx, req.(*ByteValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetNX_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByteValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetNX(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetNX",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetNX(ctx, req.(*ByteValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Hash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetMany(ctx, req.(*Hash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_Length_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).Length(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/Length",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).Length(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_GetInt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).GetInt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/GetInt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).GetInt(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_GetFloat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).GetFloat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/GetFloat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).GetFloat(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetInt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetInt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetInt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetInt(ctx, req.(*IntValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetFloat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FloatValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetFloat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetFloat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetFloat(ctx, req.(*FloatValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_IncrementInt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).IncrementInt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/IncrementInt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).IncrementInt(ctx, req.(*IntValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_DecrementInt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).DecrementInt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/DecrementInt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).DecrementInt(ctx, req.(*IntValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_IncrementFloat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FloatValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).IncrementFloat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/IncrementFloat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).IncrementFloat(ctx, req.(*FloatValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_DecrementFloat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FloatValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).DecrementFloat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/DecrementFloat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).DecrementFloat(ctx, req.(*FloatValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_GetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).GetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/GetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).GetList(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_GetListItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).GetListItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/GetListItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).GetListItem(ctx, req.(*ListItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(List)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetList(ctx, req.(*List))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetListItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetListItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetListItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetListItem(ctx, req.(*ListItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_ListLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).ListLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/ListLength",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).ListLength(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_ListLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).ListLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/ListLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).ListLimit(ctx, req.(*ListItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_ListInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).ListInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/ListInsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).ListInsert(ctx, req.(*ListItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_ListAppend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).ListAppend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/ListAppend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).ListAppend(ctx, req.(*ListItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_ListPopLeft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).ListPopLeft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/ListPopLeft",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).ListPopLeft(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_ListPopRight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).ListPopRight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/ListPopRight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).ListPopRight(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_ListHas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).ListHas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/ListHas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).ListHas(ctx, req.(*ListItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_ListDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).ListDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/ListDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).ListDelete(ctx, req.(*ListItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_ListDeleteItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).ListDeleteItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/ListDeleteItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).ListDeleteItem(ctx, req.(*ListItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_GetHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).GetHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/GetHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).GetHash(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_GetHashField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashField)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).GetHashField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/GetHashField",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).GetHashField(ctx, req.(*HashField))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_GetHashFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashFieldSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).GetHashFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/GetHashFields",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).GetHashFields(ctx, req.(*HashFieldSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_HashHas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashField)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).HashHas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/HashHas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).HashHas(ctx, req.(*HashField))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_HashLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).HashLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/HashLength",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).HashLength(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_HashFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).HashFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/HashFields",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).HashFields(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_HashValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).HashValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/HashValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).HashValues(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Hash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetHash(ctx, req.(*Hash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetHashField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashField)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetHashField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetHashField",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetHashField(ctx, req.(*HashField))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_SetHashFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Hash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).SetHashFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/SetHashFields",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).SetHashFields(ctx, req.(*Hash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_DelHashField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashField)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MydisServer).DelHashField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mydis.Mydis/DelHashField",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MydisServer).DelHashField(ctx, req.(*HashField))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mydis_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MydisServer).Watch(&mydisWatchServer{stream})
}

type Mydis_WatchServer interface {
	Send(*Event) error
	Recv() (*WatchRequest, error)
	grpc.ServerStream
}

type mydisWatchServer struct {
	grpc.ServerStream
}

func (x *mydisWatchServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mydisWatchServer) Recv() (*WatchRequest, error) {
	m := new(WatchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Mydis_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mydis.Mydis",
	HandlerType: (*MydisServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Keys",
			Handler:    _Mydis_Keys_Handler,
		},
		{
			MethodName: "KeysWithPrefix",
			Handler:    _Mydis_KeysWithPrefix_Handler,
		},
		{
			MethodName: "Has",
			Handler:    _Mydis_Has_Handler,
		},
		{
			MethodName: "SetExpire",
			Handler:    _Mydis_SetExpire_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _Mydis_Lock_Handler,
		},
		{
			MethodName: "LockWithTimeout",
			Handler:    _Mydis_LockWithTimeout_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _Mydis_Unlock_Handler,
		},
		{
			MethodName: "UnlockThenSet",
			Handler:    _Mydis_UnlockThenSet_Handler,
		},
		{
			MethodName: "UnlockThenSetList",
			Handler:    _Mydis_UnlockThenSetList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Mydis_Delete_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _Mydis_Clear_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Mydis_Get_Handler,
		},
		{
			MethodName: "GetMany",
			Handler:    _Mydis_GetMany_Handler,
		},
		{
			MethodName: "GetWithPrefix",
			Handler:    _Mydis_GetWithPrefix_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _Mydis_Set_Handler,
		},
		{
			MethodName: "SetNX",
			Handler:    _Mydis_SetNX_Handler,
		},
		{
			MethodName: "SetMany",
			Handler:    _Mydis_SetMany_Handler,
		},
		{
			MethodName: "Length",
			Handler:    _Mydis_Length_Handler,
		},
		{
			MethodName: "GetInt",
			Handler:    _Mydis_GetInt_Handler,
		},
		{
			MethodName: "GetFloat",
			Handler:    _Mydis_GetFloat_Handler,
		},
		{
			MethodName: "SetInt",
			Handler:    _Mydis_SetInt_Handler,
		},
		{
			MethodName: "SetFloat",
			Handler:    _Mydis_SetFloat_Handler,
		},
		{
			MethodName: "IncrementInt",
			Handler:    _Mydis_IncrementInt_Handler,
		},
		{
			MethodName: "DecrementInt",
			Handler:    _Mydis_DecrementInt_Handler,
		},
		{
			MethodName: "IncrementFloat",
			Handler:    _Mydis_IncrementFloat_Handler,
		},
		{
			MethodName: "DecrementFloat",
			Handler:    _Mydis_DecrementFloat_Handler,
		},
		{
			MethodName: "GetList",
			Handler:    _Mydis_GetList_Handler,
		},
		{
			MethodName: "GetListItem",
			Handler:    _Mydis_GetListItem_Handler,
		},
		{
			MethodName: "SetList",
			Handler:    _Mydis_SetList_Handler,
		},
		{
			MethodName: "SetListItem",
			Handler:    _Mydis_SetListItem_Handler,
		},
		{
			MethodName: "ListLength",
			Handler:    _Mydis_ListLength_Handler,
		},
		{
			MethodName: "ListLimit",
			Handler:    _Mydis_ListLimit_Handler,
		},
		{
			MethodName: "ListInsert",
			Handler:    _Mydis_ListInsert_Handler,
		},
		{
			MethodName: "ListAppend",
			Handler:    _Mydis_ListAppend_Handler,
		},
		{
			MethodName: "ListPopLeft",
			Handler:    _Mydis_ListPopLeft_Handler,
		},
		{
			MethodName: "ListPopRight",
			Handler:    _Mydis_ListPopRight_Handler,
		},
		{
			MethodName: "ListHas",
			Handler:    _Mydis_ListHas_Handler,
		},
		{
			MethodName: "ListDelete",
			Handler:    _Mydis_ListDelete_Handler,
		},
		{
			MethodName: "ListDeleteItem",
			Handler:    _Mydis_ListDeleteItem_Handler,
		},
		{
			MethodName: "GetHash",
			Handler:    _Mydis_GetHash_Handler,
		},
		{
			MethodName: "GetHashField",
			Handler:    _Mydis_GetHashField_Handler,
		},
		{
			MethodName: "GetHashFields",
			Handler:    _Mydis_GetHashFields_Handler,
		},
		{
			MethodName: "HashHas",
			Handler:    _Mydis_HashHas_Handler,
		},
		{
			MethodName: "HashLength",
			Handler:    _Mydis_HashLength_Handler,
		},
		{
			MethodName: "HashFields",
			Handler:    _Mydis_HashFields_Handler,
		},
		{
			MethodName: "HashValues",
			Handler:    _Mydis_HashValues_Handler,
		},
		{
			MethodName: "SetHash",
			Handler:    _Mydis_SetHash_Handler,
		},
		{
			MethodName: "SetHashField",
			Handler:    _Mydis_SetHashField_Handler,
		},
		{
			MethodName: "SetHashFields",
			Handler:    _Mydis_SetHashFields_Handler,
		},
		{
			MethodName: "DelHashField",
			Handler:    _Mydis_DelHashField_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Mydis_Watch_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "mydis.proto",
}

func init() { proto.RegisterFile("mydis.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1135 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x57, 0x4b, 0x6f, 0xdb, 0x46,
	0x10, 0x16, 0x4d, 0x3d, 0x47, 0xb2, 0x6c, 0x6f, 0x8b, 0x40, 0x10, 0x82, 0x42, 0x65, 0x1a, 0x47,
	0xf5, 0x2b, 0x86, 0xec, 0x83, 0xdb, 0x5b, 0x13, 0x2b, 0xb6, 0x10, 0x39, 0x30, 0x48, 0xa7, 0xe9,
	0x95, 0x95, 0xc6, 0x16, 0x61, 0x8a, 0x54, 0xc9, 0x95, 0x61, 0x01, 0x3d, 0xf4, 0x5c, 0xf4, 0xbf,
	0xf4, 0xd7, 0xf5, 0x5e, 0xec, 0x83, 0x14, 0x45, 0xad, 0x45, 0x19, 0xc8, 0x45, 0xe0, 0xec, 0x7e,
	0xf3, 0xcd, 0xb7, 0xb3, 0xb3, 0xb3, 0x2b, 0xa8, 0x8e, 0x67, 0x43, 0x27, 0x3c, 0x9a, 0x04, 0x3e,
	0xf5, 0x49, 0x81, 0x1b, 0x46, 0x11, 0xf2, 0x9f, 0xa6, 0xae, 0x6b, 0xfc, 0xa7, 0x81, 0xfe, 0x11,
	0x67, 0x64, 0x1b, 0xf4, 0x7b, 0x9c, 0x35, 0xb4, 0x96, 0xd6, 0xae, 0x98, 0xec, 0x93, 0x7c, 0x0b,
	0x05, 0xd7, 0x19, 0x3b, 0xb4, 0xa1, 0xb7, 0xb4, 0xb6, 0x6e, 0x0a, 0x83, 0x34, 0xa1, 0x1c, 0xe0,
	0x83, 0x13, 0x3a, 0xbe, 0xd7, 0xc8, 0xf3, 0x89, 0xd8, 0x26, 0xbb, 0x50, 0x1f, 0x3b, 0xde, 0x95,
	0x3f, 0x34, 0x23, 0x04, 0x70, 0x44, 0x6a, 0x94, 0xe3, 0xec, 0xc7, 0x24, 0xae, 0x2a, 0x71, 0x0b,
	0xa3, 0xe4, 0x00, 0x76, 0xc6, 0x8e, 0xf7, 0x3e, 0x40, 0x9b, 0x62, 0x0c, 0xad, 0x71, 0xe8, 0xf2,
	0x04, 0x47, 0xdb, 0x8f, 0x29, 0xf4, 0xa6, 0x44, 0xa7, 0x27, 0x8c, 0x97, 0x90, 0x7f, 0xe7, 0xfb,
	0x2e, 0x5b, 0xe5, 0x83, 0xed, 0x4e, 0x91, 0xaf, 0xbc, 0x6c, 0x0a, 0xc3, 0x38, 0x06, 0xe8, 0x3e,
	0x4e, 0x9c, 0xc0, 0xa6, 0x8c, 0x79, 0x39, 0x37, 0xdb, 0xa0, 0xe3, 0xe3, 0xa4, 0xb1, 0xd1, 0xd2,
	0xda, 0xc4, 0x64, 0x9f, 0xc6, 0x09, 0x54, 0xde, 0xcd, 0x28, 0xfe, 0xca, 0xdc, 0xd5, 0xc9, 0x14,
	0x61, 0x98, 0x4b, 0x2d, 0x0a, 0xd3, 0x81, 0x72, 0xcf, 0xa3, 0x6b, 0xf9, 0x90, 0xc8, 0xe7, 0x14,
	0xe0, 0x83, 0xeb, 0xdb, 0xeb, 0x79, 0x69, 0x91, 0xd7, 0x77, 0x50, 0xfe, 0x88, 0xb3, 0xb0, 0xef,
	0x84, 0x94, 0x10, 0xc8, 0xdf, 0xe3, 0x2c, 0x6c, 0x68, 0x2d, 0xbd, 0x5d, 0x31, 0xf9, 0xb7, 0x71,
	0x0e, 0x79, 0x3e, 0xb7, 0x92, 0x4f, 0x8f, 0x95, 0xab, 0x8b, 0xc3, 0xb8, 0x84, 0x32, 0x63, 0xe9,
	0x51, 0x1c, 0xab, 0x99, 0x1c, 0x6f, 0x88, 0x8f, 0x5c, 0x99, 0x6e, 0x0a, 0x63, 0xce, 0xaf, 0x27,
	0x33, 0xf3, 0x27, 0x54, 0xba, 0x41, 0xe0, 0x07, 0x97, 0x76, 0x38, 0x22, 0xa7, 0x50, 0x44, 0x66,
	0x08, 0xc9, 0xd5, 0xce, 0xcb, 0x23, 0x51, 0xd0, 0x31, 0x42, 0x7c, 0x85, 0x5d, 0x8f, 0x06, 0x33,
	0x53, 0x62, 0x9b, 0x3f, 0x41, 0x35, 0x31, 0x9c, 0x95, 0xa9, 0x8a, 0x8c, 0xfc, 0xf3, 0xc6, 0x99,
	0x66, 0xfc, 0xa3, 0x01, 0x58, 0x34, 0x70, 0xbc, 0x3b, 0x1e, 0x7f, 0xd9, 0xb5, 0x93, 0x4c, 0xca,
	0x5c, 0xd0, 0xdc, 0xe7, 0x88, 0x6f, 0x8f, 0x10, 0x24, 0xa0, 0xcd, 0x33, 0x80, 0xf9, 0xe0, 0xb3,
	0xe4, 0xfc, 0xa5, 0x41, 0xfe, 0x09, 0x21, 0x07, 0x8b, 0x42, 0x5e, 0x48, 0x21, 0x5f, 0x43, 0x42,
	0x2d, 0x29, 0xa1, 0x07, 0x15, 0xc6, 0xf9, 0xc1, 0x41, 0x77, 0xa8, 0x76, 0xbc, 0x65, 0x53, 0x91,
	0x76, 0x6e, 0x3c, 0xb1, 0xb5, 0x7d, 0xa8, 0xc5, 0x54, 0x16, 0xd2, 0xd5, 0x6c, 0xba, 0x92, 0x6d,
	0x5e, 0x88, 0x46, 0x00, 0xb5, 0x2f, 0x36, 0x1d, 0x8c, 0x4c, 0xfc, 0x63, 0x8a, 0xca, 0x02, 0x7e,
	0x01, 0xc5, 0x49, 0x80, 0xb7, 0x8e, 0xa8, 0xbb, 0xb2, 0x29, 0x2d, 0x86, 0x0c, 0xf0, 0x41, 0x16,
	0x30, 0xfb, 0x24, 0x75, 0xd8, 0x70, 0x86, 0xb2, 0xab, 0x6d, 0x38, 0x43, 0xe6, 0x39, 0xb0, 0xbd,
	0x01, 0xba, 0x8d, 0x82, 0xf0, 0x14, 0x96, 0xf1, 0xaf, 0x06, 0x85, 0xee, 0x03, 0x7a, 0x94, 0xec,
	0x41, 0x9e, 0xce, 0x26, 0xa2, 0x79, 0xd4, 0xe3, 0xec, 0xf3, 0x39, 0xf1, 0x7b, 0x33, 0x9b, 0xa0,
	0xc9, 0x31, 0x64, 0x0f, 0x4a, 0x83, 0x69, 0x10, 0xa0, 0x27, 0x0e, 0x4d, 0xb5, 0xb3, 0x2d, 0xe1,
	0x71, 0xdf, 0x30, 0x23, 0x00, 0x39, 0x80, 0xf2, 0x84, 0xb5, 0x55, 0x7f, 0x1a, 0x72, 0x3d, 0x2a,
	0x70, 0x8c, 0x30, 0x5a, 0x50, 0x89, 0x83, 0x91, 0x12, 0xe8, 0xd7, 0x9f, 0x6f, 0xb6, 0x73, 0x04,
	0xa0, 0x78, 0xde, 0xed, 0x77, 0x6f, 0xba, 0xdb, 0x5a, 0xe7, 0x6f, 0x02, 0x85, 0x2b, 0xe6, 0x4f,
	0x76, 0x21, 0xcf, 0x1a, 0x01, 0xa9, 0x4a, 0x3e, 0x76, 0x09, 0x34, 0xb7, 0xa4, 0x11, 0xb5, 0x08,
	0x23, 0x47, 0xde, 0x42, 0x9d, 0x59, 0x5f, 0x1c, 0x3a, 0xba, 0x16, 0xf9, 0x82, 0x39, 0x48, 0xe5,
	0xd0, 0x02, 0xfd, 0xd2, 0x0e, 0x17, 0x50, 0x51, 0x0c, 0xd6, 0x68, 0x8d, 0x1c, 0x39, 0x84, 0x8a,
	0x85, 0x94, 0xf7, 0x55, 0x24, 0x3b, 0x51, 0xae, 0xe2, 0x36, 0xdb, 0x4c, 0x4a, 0x32, 0x72, 0xe4,
	0x7b, 0xc8, 0xf7, 0xfd, 0xc1, 0xbd, 0x92, 0x51, 0x42, 0x4e, 0x60, 0x8b, 0x41, 0x98, 0xc8, 0x1b,
	0x67, 0x8c, 0xfe, 0x94, 0xae, 0xc1, 0xfb, 0x0a, 0x8a, 0x9f, 0x3d, 0x37, 0x83, 0xf9, 0x18, 0x36,
	0x05, 0xe8, 0x66, 0x84, 0x1e, 0xaf, 0xd2, 0x74, 0xfe, 0xd3, 0x1e, 0x6f, 0x61, 0x67, 0xc1, 0x83,
	0xb7, 0xd3, 0x08, 0xc3, 0x0c, 0x85, 0x8e, 0x73, 0x74, 0x91, 0xe2, 0x2a, 0x1d, 0xaf, 0xa0, 0xf0,
	0xde, 0x45, 0x3b, 0x58, 0xdc, 0xaf, 0x14, 0xe8, 0x35, 0xe8, 0x17, 0x48, 0x17, 0x68, 0x96, 0xe4,
	0x1a, 0x39, 0xf2, 0x23, 0x94, 0x2e, 0x90, 0x5e, 0xd9, 0xde, 0x8c, 0xa4, 0xf7, 0x2f, 0x66, 0x64,
	0x27, 0xd3, 0xc8, 0x91, 0x3d, 0xd8, 0xbc, 0x40, 0xfa, 0xc4, 0xe6, 0xa7, 0xb0, 0xbb, 0xa0, 0xaf,
	0x95, 0xa0, 0x36, 0x14, 0x2c, 0xa4, 0x9f, 0x7e, 0x5b, 0x81, 0x94, 0x85, 0xb2, 0x07, 0x25, 0x4b,
	0x0a, 0x4d, 0xc6, 0x8a, 0x17, 0x15, 0xf7, 0x7d, 0x23, 0x47, 0xde, 0x40, 0xb1, 0x8f, 0xde, 0x1d,
	0x1d, 0x29, 0xeb, 0x33, 0xba, 0x5d, 0x05, 0xf0, 0x02, 0x69, 0xcf, 0xa3, 0x59, 0xc0, 0x7d, 0x28,
	0x5f, 0x20, 0xe5, 0x77, 0xec, 0x02, 0x34, 0xaa, 0xac, 0xf9, 0xed, 0xcb, 0x17, 0x55, 0xb4, 0x04,
	0x6b, 0x9a, 0x29, 0xbd, 0xfc, 0x03, 0x28, 0x5b, 0x11, 0xed, 0x32, 0x55, 0x1a, 0xdd, 0x81, 0x5a,
	0xcf, 0x1b, 0x04, 0x38, 0x46, 0x4f, 0xcd, 0xae, 0x10, 0xde, 0x81, 0xda, 0x39, 0x3e, 0xd3, 0xe7,
	0x0c, 0xea, 0x71, 0x9c, 0x27, 0xb5, 0x29, 0x57, 0x7e, 0x06, 0xf5, 0x38, 0xda, 0xf3, 0x3c, 0x7f,
	0xe0, 0x75, 0xc8, 0xcf, 0x87, 0xaa, 0xac, 0x64, 0x3f, 0xe9, 0x40, 0x55, 0xa2, 0xf8, 0x73, 0x62,
	0x2b, 0x31, 0xcb, 0x06, 0x94, 0x15, 0xfe, 0x9a, 0x17, 0x4e, 0xe6, 0xc9, 0x3b, 0x84, 0xaa, 0xb5,
	0x8a, 0x3a, 0x05, 0xdf, 0x07, 0x60, 0x53, 0xeb, 0x95, 0xd9, 0x3e, 0x54, 0x38, 0x98, 0x3f, 0x96,
	0xb3, 0x98, 0x0f, 0x04, 0x73, 0xcf, 0x0b, 0x31, 0x58, 0x1b, 0xfd, 0xcb, 0x64, 0x82, 0xde, 0x30,
	0x13, 0x7d, 0x08, 0x55, 0x36, 0x75, 0xed, 0x4f, 0xfa, 0x78, 0x9b, 0xdd, 0x1c, 0x8e, 0xa0, 0x26,
	0xe1, 0xa6, 0x73, 0x37, 0xca, 0xc6, 0x1f, 0x42, 0x89, 0xe1, 0x59, 0xcb, 0x5f, 0x52, 0xa2, 0x48,
	0x8b, 0xd4, 0x2e, 0x1b, 0x5e, 0x96, 0xf6, 0x53, 0xa8, 0xcf, 0xd1, 0xea, 0x3d, 0x52, 0xc4, 0x10,
	0x75, 0xc5, 0x1f, 0x4a, 0x2b, 0xda, 0xd5, 0x29, 0xd4, 0x24, 0x4a, 0x3e, 0x66, 0x12, 0xd3, 0x7c,
	0x44, 0xb9, 0xdc, 0x13, 0xde, 0x10, 0x63, 0x4c, 0x48, 0xbe, 0x49, 0xbb, 0x59, 0xa8, 0xe8, 0xa2,
	0x25, 0xf6, 0xc5, 0x72, 0xb4, 0x1c, 0x25, 0xd5, 0xf3, 0xf6, 0x01, 0xd8, 0xdc, 0xba, 0x45, 0x06,
	0x09, 0x29, 0x19, 0x17, 0xf3, 0x1b, 0x01, 0xe6, 0xbe, 0xe1, 0xaa, 0x13, 0x27, 0x4e, 0x0f, 0xcf,
	0xdf, 0x42, 0xdb, 0x5d, 0xba, 0xe8, 0x6a, 0xd6, 0xea, 0x04, 0x2e, 0x9d, 0x9f, 0x4d, 0x6b, 0x21,
	0x77, 0x19, 0xec, 0xe7, 0xe8, 0x3e, 0x83, 0xfd, 0x18, 0x0a, 0xfc, 0x01, 0x18, 0xef, 0x48, 0xf2,
	0x39, 0xd8, 0xac, 0x25, 0x9f, 0x64, 0x46, 0xae, 0xad, 0x1d, 0x6b, 0xbf, 0x17, 0xf9, 0x1f, 0xe1,
	0x93, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0xd8, 0x83, 0xb8, 0x38, 0x17, 0x0f, 0x00, 0x00,
}
